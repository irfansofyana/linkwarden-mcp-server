// Package linkwarden provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package linkwarden

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for CollectionIconWeight.
const (
	CollectionIconWeightBold    CollectionIconWeight = "bold"
	CollectionIconWeightDuotone CollectionIconWeight = "duotone"
	CollectionIconWeightFill    CollectionIconWeight = "fill"
	CollectionIconWeightLight   CollectionIconWeight = "light"
	CollectionIconWeightRegular CollectionIconWeight = "regular"
	CollectionIconWeightThin    CollectionIconWeight = "thin"
)

// Defines values for CollectionWithLinksIconWeight.
const (
	CollectionWithLinksIconWeightBold    CollectionWithLinksIconWeight = "bold"
	CollectionWithLinksIconWeightDuotone CollectionWithLinksIconWeight = "duotone"
	CollectionWithLinksIconWeightFill    CollectionWithLinksIconWeight = "fill"
	CollectionWithLinksIconWeightLight   CollectionWithLinksIconWeight = "light"
	CollectionWithLinksIconWeightRegular CollectionWithLinksIconWeight = "regular"
	CollectionWithLinksIconWeightThin    CollectionWithLinksIconWeight = "thin"
)

// Defines values for LinkCollectionIconWeight.
const (
	LinkCollectionIconWeightBold    LinkCollectionIconWeight = "bold"
	LinkCollectionIconWeightDuotone LinkCollectionIconWeight = "duotone"
	LinkCollectionIconWeightFill    LinkCollectionIconWeight = "fill"
	LinkCollectionIconWeightLight   LinkCollectionIconWeight = "light"
	LinkCollectionIconWeightRegular LinkCollectionIconWeight = "regular"
	LinkCollectionIconWeightThin    LinkCollectionIconWeight = "thin"
)

// Defines values for LinkIconWeight.
const (
	LinkIconWeightBold    LinkIconWeight = "bold"
	LinkIconWeightDuotone LinkIconWeight = "duotone"
	LinkIconWeightFill    LinkIconWeight = "fill"
	LinkIconWeightLight   LinkIconWeight = "light"
	LinkIconWeightRegular LinkIconWeight = "regular"
	LinkIconWeightThin    LinkIconWeight = "thin"
)

// Defines values for LinkWithTagsCollectionIconWeight.
const (
	LinkWithTagsCollectionIconWeightBold    LinkWithTagsCollectionIconWeight = "bold"
	LinkWithTagsCollectionIconWeightDuotone LinkWithTagsCollectionIconWeight = "duotone"
	LinkWithTagsCollectionIconWeightFill    LinkWithTagsCollectionIconWeight = "fill"
	LinkWithTagsCollectionIconWeightLight   LinkWithTagsCollectionIconWeight = "light"
	LinkWithTagsCollectionIconWeightRegular LinkWithTagsCollectionIconWeight = "regular"
	LinkWithTagsCollectionIconWeightThin    LinkWithTagsCollectionIconWeight = "thin"
)

// Defines values for LinkWithTagsIconWeight.
const (
	LinkWithTagsIconWeightBold    LinkWithTagsIconWeight = "bold"
	LinkWithTagsIconWeightDuotone LinkWithTagsIconWeight = "duotone"
	LinkWithTagsIconWeightFill    LinkWithTagsIconWeight = "fill"
	LinkWithTagsIconWeightLight   LinkWithTagsIconWeight = "light"
	LinkWithTagsIconWeightRegular LinkWithTagsIconWeight = "regular"
	LinkWithTagsIconWeightThin    LinkWithTagsIconWeight = "thin"
)

// Defines values for GetApiV1ArchivesLinkIdParamsFormat.
const (
	GetApiV1ArchivesLinkIdParamsFormatN0 GetApiV1ArchivesLinkIdParamsFormat = 0
	GetApiV1ArchivesLinkIdParamsFormatN1 GetApiV1ArchivesLinkIdParamsFormat = 1
	GetApiV1ArchivesLinkIdParamsFormatN2 GetApiV1ArchivesLinkIdParamsFormat = 2
	GetApiV1ArchivesLinkIdParamsFormatN3 GetApiV1ArchivesLinkIdParamsFormat = 3
	GetApiV1ArchivesLinkIdParamsFormatN4 GetApiV1ArchivesLinkIdParamsFormat = 4
)

// Defines values for PostApiV1ArchivesLinkIdParamsFormat.
const (
	PostApiV1ArchivesLinkIdParamsFormatN0 PostApiV1ArchivesLinkIdParamsFormat = 0
	PostApiV1ArchivesLinkIdParamsFormatN1 PostApiV1ArchivesLinkIdParamsFormat = 1
	PostApiV1ArchivesLinkIdParamsFormatN2 PostApiV1ArchivesLinkIdParamsFormat = 2
)

// Defines values for PutApiV1ArchivesLinkIdParamsFormat.
const (
	PutApiV1ArchivesLinkIdParamsFormatN0 PutApiV1ArchivesLinkIdParamsFormat = 0
	PutApiV1ArchivesLinkIdParamsFormatN1 PutApiV1ArchivesLinkIdParamsFormat = 1
	PutApiV1ArchivesLinkIdParamsFormatN2 PutApiV1ArchivesLinkIdParamsFormat = 2
	PutApiV1ArchivesLinkIdParamsFormatN3 PutApiV1ArchivesLinkIdParamsFormat = 3
	PutApiV1ArchivesLinkIdParamsFormatN4 PutApiV1ArchivesLinkIdParamsFormat = 4
)

// Defines values for CreateLinkJSONBodyType.
const (
	Image CreateLinkJSONBodyType = "image"
	Pdf   CreateLinkJSONBodyType = "pdf"
	Url   CreateLinkJSONBodyType = "url"
)

// Defines values for PostApiV1MigrationMultipartBodyFormat.
const (
	PostApiV1MigrationMultipartBodyFormatN0 PostApiV1MigrationMultipartBodyFormat = 0
	PostApiV1MigrationMultipartBodyFormatN1 PostApiV1MigrationMultipartBodyFormat = 1
	PostApiV1MigrationMultipartBodyFormatN2 PostApiV1MigrationMultipartBodyFormat = 2
)

// Defines values for UpdateUserJSONBodyLinksRouteTo.
const (
	CUSTOM   UpdateUserJSONBodyLinksRouteTo = "CUSTOM"
	ORIGINAL UpdateUserJSONBodyLinksRouteTo = "ORIGINAL"
)

// Collection defines model for Collection.
type Collection struct {
	UnderscoreCount *struct {
		Links *int `json:"links,omitempty"`
	} `json:"_count,omitempty"`
	Color       *string    `json:"color,omitempty"`
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	CreatedById *int       `json:"createdById,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Icon Acorn
	Icon       *string               `json:"icon"`
	IconWeight *CollectionIconWeight `json:"iconWeight"`
	Id         *int                  `json:"id,omitempty"`
	IsPublic   *bool                 `json:"isPublic,omitempty"`
	Members    *[]CollectionMember   `json:"members,omitempty"`
	Name       *string               `json:"name,omitempty"`
	OwnerId    *int                  `json:"ownerId,omitempty"`
	ParentId   *int                  `json:"parentId"`
	UpdatedAt  *time.Time            `json:"updatedAt,omitempty"`
}

// CollectionIconWeight defines model for Collection.IconWeight.
type CollectionIconWeight string

// CollectionMember defines model for CollectionMember.
type CollectionMember struct {
	CanCreate    *bool      `json:"canCreate,omitempty"`
	CanDelete    *bool      `json:"canDelete,omitempty"`
	CanUpdate    *bool      `json:"canUpdate,omitempty"`
	CollectionId *int       `json:"collectionId,omitempty"`
	CreatedAt    *time.Time `json:"createdAt,omitempty"`
	UpdatedAt    *time.Time `json:"updatedAt,omitempty"`
	User         *struct {
		Image    *string `json:"image"`
		Name     *string `json:"name,omitempty"`
		Username *string `json:"username,omitempty"`
	} `json:"user,omitempty"`
	UserId *int `json:"userId,omitempty"`
}

// CollectionResponse defines model for CollectionResponse.
type CollectionResponse struct {
	Response *Collection `json:"response,omitempty"`
}

// CollectionWithLinks defines model for CollectionWithLinks.
type CollectionWithLinks struct {
	UnderscoreCount *struct {
		Links *int `json:"links,omitempty"`
	} `json:"_count,omitempty"`
	Color       *string    `json:"color,omitempty"`
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	CreatedById *int       `json:"createdById,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Icon Acorn
	Icon       *string                        `json:"icon"`
	IconWeight *CollectionWithLinksIconWeight `json:"iconWeight"`
	Id         *int                           `json:"id,omitempty"`
	IsPublic   *bool                          `json:"isPublic,omitempty"`
	Links      *[]LinkWithTags                `json:"links,omitempty"`
	Members    *[]CollectionMember            `json:"members,omitempty"`
	Name       *string                        `json:"name,omitempty"`
	OwnerId    *int                           `json:"ownerId,omitempty"`
	ParentId   *int                           `json:"parentId"`
	UpdatedAt  *time.Time                     `json:"updatedAt,omitempty"`
}

// CollectionWithLinksIconWeight defines model for CollectionWithLinks.IconWeight.
type CollectionWithLinksIconWeight string

// CollectionsResponse defines model for CollectionsResponse.
type CollectionsResponse struct {
	Response *[]Collection `json:"response,omitempty"`
}

// CreateTokenData defines model for CreateTokenData.
type CreateTokenData struct {
	Response *CreateTokenResult `json:"response,omitempty"`
}

// CreateTokenResult defines model for CreateTokenResult.
type CreateTokenResult struct {
	// SecretKey The secret key for the token.
	SecretKey *string `json:"secretKey,omitempty"`
	Token     *Token  `json:"token,omitempty"`
}

// DashboardResponse defines model for DashboardResponse.
type DashboardResponse struct {
	Response *[]Link `json:"response,omitempty"`
}

// DashboardV2Data defines model for DashboardV2Data.
type DashboardV2Data struct {
	Collections         *[]Collection `json:"collections,omitempty"`
	Links               *[]Link       `json:"links,omitempty"`
	NumberOfPinnedLinks *int          `json:"numberOfPinnedLinks,omitempty"`
	Tags                *[]Tag        `json:"tags,omitempty"`
}

// DashboardV2Response defines model for DashboardV2Response.
type DashboardV2Response struct {
	Data    *DashboardV2Data `json:"data,omitempty"`
	Message *string          `json:"message,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Response *string `json:"response,omitempty"`
}

// Link defines model for Link.
type Link struct {
	Collection *struct {
		Color       *string    `json:"color,omitempty"`
		CreatedAt   *time.Time `json:"createdAt,omitempty"`
		CreatedById *int       `json:"createdById,omitempty"`
		Description *string    `json:"description,omitempty"`

		// Icon Acorn
		Icon       *string                   `json:"icon"`
		IconWeight *LinkCollectionIconWeight `json:"iconWeight"`
		Id         *int                      `json:"id,omitempty"`
		IsPublic   *bool                     `json:"isPublic,omitempty"`
		Name       *string                   `json:"name,omitempty"`
		OwnerId    *int                      `json:"ownerId,omitempty"`
		ParentId   *int                      `json:"parentId"`
		UpdatedAt  *time.Time                `json:"updatedAt,omitempty"`
	} `json:"collection,omitempty"`
	CollectionId  *int            `json:"collectionId,omitempty"`
	Color         *string         `json:"color,omitempty"`
	CreatedAt     *time.Time      `json:"createdAt,omitempty"`
	CreatedById   *int            `json:"createdById,omitempty"`
	Description   *string         `json:"description,omitempty"`
	Icon          *string         `json:"icon"`
	IconWeight    *LinkIconWeight `json:"iconWeight"`
	Id            *int            `json:"id,omitempty"`
	Image         *string         `json:"image"`
	ImportDate    *string         `json:"importDate"`
	LastPreserved *time.Time      `json:"lastPreserved"`
	Monolith      *string         `json:"monolith"`
	Name          *string         `json:"name,omitempty"`
	Pdf           *string         `json:"pdf"`
	PinnedBy      *[]int          `json:"pinnedBy,omitempty"`
	Preview       *string         `json:"preview"`
	Readable      *string         `json:"readable"`
	Tags          *[]struct {
		CreatedAt *time.Time `json:"createdAt,omitempty"`
		Id        *int       `json:"id,omitempty"`
		Name      *string    `json:"name,omitempty"`
		OwnerId   *int       `json:"ownerId,omitempty"`
		UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	} `json:"tags,omitempty"`
	TextContent *string    `json:"textContent"`
	Type        *string    `json:"type,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	Url         *string    `json:"url,omitempty"`
}

// LinkCollectionIconWeight defines model for Link.Collection.IconWeight.
type LinkCollectionIconWeight string

// LinkIconWeight defines model for Link.IconWeight.
type LinkIconWeight string

// LinkResponse defines model for LinkResponse.
type LinkResponse struct {
	Response *Link `json:"response,omitempty"`
}

// LinkWithTags defines model for LinkWithTags.
type LinkWithTags struct {
	Collection *struct {
		Color       *string    `json:"color,omitempty"`
		CreatedAt   *time.Time `json:"createdAt,omitempty"`
		CreatedById *int       `json:"createdById,omitempty"`
		Description *string    `json:"description,omitempty"`

		// Icon Acorn
		Icon       *string                           `json:"icon"`
		IconWeight *LinkWithTagsCollectionIconWeight `json:"iconWeight"`
		Id         *int                              `json:"id,omitempty"`
		IsPublic   *bool                             `json:"isPublic,omitempty"`
		Name       *string                           `json:"name,omitempty"`
		OwnerId    *int                              `json:"ownerId,omitempty"`
		ParentId   *int                              `json:"parentId"`
		UpdatedAt  *time.Time                        `json:"updatedAt,omitempty"`
	} `json:"collection,omitempty"`
	CollectionId  *int                    `json:"collectionId,omitempty"`
	Color         *string                 `json:"color,omitempty"`
	CreatedAt     *time.Time              `json:"createdAt,omitempty"`
	CreatedById   *int                    `json:"createdById,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	Icon          *string                 `json:"icon"`
	IconWeight    *LinkWithTagsIconWeight `json:"iconWeight"`
	Id            *int                    `json:"id,omitempty"`
	Image         *string                 `json:"image"`
	ImportDate    *string                 `json:"importDate"`
	LastPreserved *time.Time              `json:"lastPreserved"`
	Monolith      *string                 `json:"monolith"`
	Name          *string                 `json:"name,omitempty"`
	Pdf           *string                 `json:"pdf"`
	PinnedBy      *[]int                  `json:"pinnedBy,omitempty"`
	Preview       *string                 `json:"preview"`
	Readable      *string                 `json:"readable"`
	Tags          *[]Tag                  `json:"tags,omitempty"`
	TextContent   *string                 `json:"textContent"`
	Type          *string                 `json:"type,omitempty"`
	UpdatedAt     *time.Time              `json:"updatedAt,omitempty"`
	Url           *string                 `json:"url,omitempty"`
}

// LinkWithTagsCollectionIconWeight defines model for LinkWithTags.Collection.IconWeight.
type LinkWithTagsCollectionIconWeight string

// LinkWithTagsIconWeight defines model for LinkWithTags.IconWeight.
type LinkWithTagsIconWeight string

// LinksResponse defines model for LinksResponse.
type LinksResponse struct {
	Response *[]Link `json:"response,omitempty"`
}

// LoginConfig defines model for LoginConfig.
type LoginConfig struct {
	// ButtonAuths List of available button-based authentication methods.
	ButtonAuths *[]struct {
		// Method The method used for authentication.
		Method *string `json:"method,omitempty"`

		// Name The name of the authentication method.
		Name *string `json:"name,omitempty"`
	} `json:"buttonAuths,omitempty"`

	// CredentialsEnabled Indicates if credentials-based login is enabled.
	CredentialsEnabled *string `json:"credentialsEnabled"`

	// EmailEnabled Indicates if email-based login is enabled.
	EmailEnabled *string `json:"emailEnabled"`

	// RegistrationDisabled Indicates if registration is disabled.
	RegistrationDisabled *string `json:"registrationDisabled"`
}

// LoginConfigResponse defines model for LoginConfigResponse.
type LoginConfigResponse struct {
	Response *LoginConfig `json:"response,omitempty"`
}

// MigrationData defines model for MigrationData.
type MigrationData struct {
	ArchiveAsMonolith       *bool                  `json:"archiveAsMonolith,omitempty"`
	ArchiveAsPDF            *bool                  `json:"archiveAsPDF,omitempty"`
	ArchiveAsScreenshot     *bool                  `json:"archiveAsScreenshot,omitempty"`
	ArchiveAsWaybackMachine *bool                  `json:"archiveAsWaybackMachine,omitempty"`
	CollectionOrder         *[]int                 `json:"collectionOrder,omitempty"`
	Collections             *[]CollectionWithLinks `json:"collections,omitempty"`
	CreatedAt               *time.Time             `json:"createdAt,omitempty"`
	Email                   *string                `json:"email"`
	EmailVerified           *string                `json:"emailVerified"`
	Image                   *string                `json:"image,omitempty"`
	IsPrivate               *bool                  `json:"isPrivate,omitempty"`
	LinksRouteTo            *string                `json:"linksRouteTo,omitempty"`
	Locale                  *string                `json:"locale,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	ParentSubscriptionId    *string                `json:"parentSubscriptionId"`
	PinnedLinks             *[]Link                `json:"pinnedLinks,omitempty"`
	PreventDuplicateLinks   *bool                  `json:"preventDuplicateLinks,omitempty"`
	ReferredBy              *string                `json:"referredBy"`
	UnverifiedNewEmail      *string                `json:"unverifiedNewEmail"`
	UpdatedAt               *time.Time             `json:"updatedAt,omitempty"`
	Username                *string                `json:"username,omitempty"`
	WhitelistedUsers        *[]string              `json:"whitelistedUsers,omitempty"`
}

// MigrationResponse defines model for MigrationResponse.
type MigrationResponse struct {
	Response *MigrationData `json:"response,omitempty"`
}

// PublicUser defines model for PublicUser.
type PublicUser struct {
	ArchiveAsMonolith   *bool   `json:"archiveAsMonolith,omitempty"`
	ArchiveAsPDF        *bool   `json:"archiveAsPDF,omitempty"`
	ArchiveAsScreenshot *bool   `json:"archiveAsScreenshot,omitempty"`
	Email               *string `json:"email"`
	Id                  *int    `json:"id,omitempty"`
	Image               *string `json:"image,omitempty"`
	Name                *string `json:"name,omitempty"`
	Username            *string `json:"username,omitempty"`
}

// PublicUserResponse defines model for PublicUserResponse.
type PublicUserResponse struct {
	Response *PublicUser `json:"response,omitempty"`
}

// SearchData defines model for SearchData.
type SearchData struct {
	Links      *[]Link `json:"links,omitempty"`
	NextCursor *int    `json:"nextCursor"`
}

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Data    *SearchData `json:"data,omitempty"`
	Message *string     `json:"message,omitempty"`
}

// SessionResponse defines model for SessionResponse.
type SessionResponse struct {
	Response *SessionResult `json:"response,omitempty"`
}

// SessionResult defines model for SessionResult.
type SessionResult struct {
	// Token The token generated for the session.
	Token *string `json:"token,omitempty"`
}

// Tag defines model for Tag.
type Tag struct {
	UnderscoreCount *struct {
		Links *int `json:"links,omitempty"`
	} `json:"_count,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Id        *int       `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	OwnerId   *int       `json:"ownerId,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// TagResponse defines model for TagResponse.
type TagResponse struct {
	Response *Tag `json:"response,omitempty"`
}

// TagsResponse defines model for TagsResponse.
type TagsResponse struct {
	Response *[]Tag `json:"response,omitempty"`
}

// Token defines model for Token.
type Token struct {
	CreatedAt  *time.Time `json:"createdAt,omitempty"`
	Expires    *time.Time `json:"expires,omitempty"`
	Id         *int       `json:"id,omitempty"`
	IsSession  *bool      `json:"isSession,omitempty"`
	LastUsedAt *time.Time `json:"lastUsedAt"`
	Name       *string    `json:"name,omitempty"`
	Revoked    *bool      `json:"revoked,omitempty"`
	Token      *string    `json:"token,omitempty"`
	UpdatedAt  *time.Time `json:"updatedAt,omitempty"`
	UserId     *int       `json:"userId,omitempty"`
}

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	Response *Token `json:"response,omitempty"`
}

// TokenSummary defines model for TokenSummary.
type TokenSummary struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Expires   *time.Time `json:"expires,omitempty"`
	Id        *int       `json:"id,omitempty"`
	IsSession *bool      `json:"isSession,omitempty"`
	Name      *string    `json:"name,omitempty"`
}

// TokensResponse defines model for TokensResponse.
type TokensResponse struct {
	Response *[]TokenSummary `json:"response,omitempty"`
}

// User defines model for User.
type User struct {
	ArchiveAsMonolith       *bool      `json:"archiveAsMonolith,omitempty"`
	ArchiveAsPDF            *bool      `json:"archiveAsPDF,omitempty"`
	ArchiveAsScreenshot     *bool      `json:"archiveAsScreenshot,omitempty"`
	ArchiveAsWaybackMachine *bool      `json:"archiveAsWaybackMachine,omitempty"`
	CollectionOrder         *[]int     `json:"collectionOrder,omitempty"`
	CreatedAt               *time.Time `json:"createdAt,omitempty"`
	Email                   *string    `json:"email"`
	EmailVerified           *string    `json:"emailVerified"`
	Id                      *int       `json:"id,omitempty"`
	Image                   *string    `json:"image"`
	IsPrivate               *bool      `json:"isPrivate,omitempty"`
	LinksRouteTo            *string    `json:"linksRouteTo,omitempty"`
	Locale                  *string    `json:"locale,omitempty"`
	Name                    *string    `json:"name,omitempty"`
	ParentSubscription      *struct {
		User *map[string]interface{} `json:"user"`
	} `json:"parentSubscription"`
	ParentSubscriptionId  *string                 `json:"parentSubscriptionId"`
	PreventDuplicateLinks *bool                   `json:"preventDuplicateLinks,omitempty"`
	ReferredBy            *string                 `json:"referredBy"`
	Subscription          *map[string]interface{} `json:"subscription"`
	UnverifiedNewEmail    *string                 `json:"unverifiedNewEmail"`
	UpdatedAt             *time.Time              `json:"updatedAt,omitempty"`
	Username              *string                 `json:"username,omitempty"`
	WhitelistedUsers      *[]string               `json:"whitelistedUsers,omitempty"`
}

// UserResponse defines model for UserResponse.
type UserResponse struct {
	Response *User `json:"response,omitempty"`
}

// UserSummary defines model for UserSummary.
type UserSummary struct {
	CreatedAt     *time.Time              `json:"createdAt,omitempty"`
	Email         *string                 `json:"email"`
	EmailVerified *string                 `json:"emailVerified"`
	Id            *int                    `json:"id,omitempty"`
	Subscription  *map[string]interface{} `json:"subscription"`
	Username      *string                 `json:"username,omitempty"`
}

// UsersResponse defines model for UsersResponse.
type UsersResponse struct {
	Response *[]UserSummary `json:"response,omitempty"`
}

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// Forbidden defines model for Forbidden.
type Forbidden = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// GetApiV1ArchivesLinkIdParams defines parameters for GetApiV1ArchivesLinkId.
type GetApiV1ArchivesLinkIdParams struct {
	// Format The numeric value corresponding to the format of the file being uploaded:
	// - `0`: PNG
	// - `1`: JPEG
	// - `2`: PDF
	// - `3`: Readability JSON
	// - `4` Monolith HTML
	Format *GetApiV1ArchivesLinkIdParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// Preview Indicates whether to return a preview of the archive.
	Preview *bool `form:"preview,omitempty" json:"preview,omitempty"`
}

// GetApiV1ArchivesLinkIdParamsFormat defines parameters for GetApiV1ArchivesLinkId.
type GetApiV1ArchivesLinkIdParamsFormat int

// PostApiV1ArchivesLinkIdMultipartBody defines parameters for PostApiV1ArchivesLinkId.
type PostApiV1ArchivesLinkIdMultipartBody struct {
	// File The file to upload (PNG, JPEG, or PDF).
	File openapi_types.File `json:"file"`
}

// PostApiV1ArchivesLinkIdParams defines parameters for PostApiV1ArchivesLinkId.
type PostApiV1ArchivesLinkIdParams struct {
	// Format The numeric value corresponding to the format of the file being uploaded:
	// - `0`: PNG
	// - `1`: JPEG
	// - `2`: PDF
	Format PostApiV1ArchivesLinkIdParamsFormat `form:"format" json:"format"`
}

// PostApiV1ArchivesLinkIdParamsFormat defines parameters for PostApiV1ArchivesLinkId.
type PostApiV1ArchivesLinkIdParamsFormat int

// PutApiV1ArchivesLinkIdMultipartBody defines parameters for PutApiV1ArchivesLinkId.
type PutApiV1ArchivesLinkIdMultipartBody struct {
	// File The file to upload (PNG, JPEG, or PDF).
	File openapi_types.File `json:"file"`
}

// PutApiV1ArchivesLinkIdParams defines parameters for PutApiV1ArchivesLinkId.
type PutApiV1ArchivesLinkIdParams struct {
	// Format The numeric value corresponding to the format of the file being uploaded:
	// - `0`: PNG
	// - `1`: JPEG
	// - `2`: PDF
	// - `3`: Readability JSON
	// - `4` Monolith HTML
	Format *PutApiV1ArchivesLinkIdParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// PutApiV1ArchivesLinkIdParamsFormat defines parameters for PutApiV1ArchivesLinkId.
type PutApiV1ArchivesLinkIdParamsFormat int

// PostApiV1AuthForgotPasswordJSONBody defines parameters for PostApiV1AuthForgotPassword.
type PostApiV1AuthForgotPasswordJSONBody struct {
	// Email The email of the user requesting the password reset.
	Email openapi_types.Email `json:"email"`
}

// PostApiV1AuthResetPasswordJSONBody defines parameters for PostApiV1AuthResetPassword.
type PostApiV1AuthResetPasswordJSONBody struct {
	// Password The new password to set.
	Password string `json:"password"`

	// Token The password reset token.
	Token string `json:"token"`
}

// PostApiV1AuthVerifyEmailParams defines parameters for PostApiV1AuthVerifyEmail.
type PostApiV1AuthVerifyEmailParams struct {
	// Token The verification token sent to the user's email.
	Token string `form:"token" json:"token"`
}

// CreateCollectionJSONBody defines parameters for CreateCollection.
type CreateCollectionJSONBody struct {
	// Color The color of the collection.
	Color *string `json:"color,omitempty"`

	// Description The description of the collection.
	Description *string `json:"description,omitempty"`

	// Icon The icon of the collection.
	Icon *string `json:"icon,omitempty"`

	// IconWeight The weight of the collection's icon.
	IconWeight *string `json:"iconWeight,omitempty"`

	// Name The name of the collection.
	Name *string `json:"name,omitempty"`

	// ParentId The ID of the parent collection, if applicable.
	ParentId *int `json:"parentId,omitempty"`
}

// UpdateCollectionJSONBody defines parameters for UpdateCollection.
type UpdateCollectionJSONBody struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Icon        *string `json:"icon,omitempty"`
	IconWeight  *string `json:"iconWeight,omitempty"`
	IsPublic    *bool   `json:"isPublic,omitempty"`
	Members     *[]struct {
		CanCreate *bool `json:"canCreate,omitempty"`
		CanDelete *bool `json:"canDelete,omitempty"`
		CanUpdate *bool `json:"canUpdate,omitempty"`
		UserId    *int  `json:"userId,omitempty"`
	} `json:"members,omitempty"`
	Name     *string `json:"name,omitempty"`
	ParentId *int    `json:"parentId,omitempty"`
}

// DeleteLinksJSONBody defines parameters for DeleteLinks.
type DeleteLinksJSONBody struct {
	// LinkIds List of link IDs to be deleted.
	LinkIds *[]int `json:"linkIds,omitempty"`
}

// GetApiV1LinksParams defines parameters for GetApiV1Links.
type GetApiV1LinksParams struct {
	Sort                *int    `form:"sort,omitempty" json:"sort,omitempty"`
	Cursor              *int    `form:"cursor,omitempty" json:"cursor,omitempty"`
	CollectionId        *int    `form:"collectionId,omitempty" json:"collectionId,omitempty"`
	TagId               *int    `form:"tagId,omitempty" json:"tagId,omitempty"`
	PinnedOnly          *bool   `form:"pinnedOnly,omitempty" json:"pinnedOnly,omitempty"`
	SearchQueryString   *string `form:"searchQueryString,omitempty" json:"searchQueryString,omitempty"`
	SearchByName        *bool   `form:"searchByName,omitempty" json:"searchByName,omitempty"`
	SearchByUrl         *bool   `form:"searchByUrl,omitempty" json:"searchByUrl,omitempty"`
	SearchByDescription *bool   `form:"searchByDescription,omitempty" json:"searchByDescription,omitempty"`
	SearchByTextContent *bool   `form:"searchByTextContent,omitempty" json:"searchByTextContent,omitempty"`
	SearchByTags        *bool   `form:"searchByTags,omitempty" json:"searchByTags,omitempty"`
}

// CreateLinkJSONBody defines parameters for CreateLink.
type CreateLinkJSONBody struct {
	Collection *struct {
		Id   *int    `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"collection,omitempty"`
	Description *string `json:"description"`
	Name        *string `json:"name"`
	Tags        *[]struct {
		Id   *int    `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"tags,omitempty"`
	Type *CreateLinkJSONBodyType `json:"type"`
	Url  *string                 `json:"url"`
}

// CreateLinkJSONBodyType defines parameters for CreateLink.
type CreateLinkJSONBodyType string

// BulkUpdateLinksJSONBody defines parameters for BulkUpdateLinks.
type BulkUpdateLinksJSONBody struct {
	Links   *[]Link `json:"links,omitempty"`
	NewData *struct {
		CollectionId *int `json:"collectionId,omitempty"`
		Tags         *[]struct {
			Id   *int    `json:"id"`
			Name *string `json:"name,omitempty"`
		} `json:"tags,omitempty"`
	} `json:"newData,omitempty"`
	RemovePreviousTags *bool `json:"removePreviousTags,omitempty"`
}

// UpdateLinkJSONBody defines parameters for UpdateLink.
type UpdateLinkJSONBody struct {
	Collection *struct {
		Id      *int `json:"id,omitempty"`
		OwnerId *int `json:"ownerId,omitempty"`
	} `json:"collection,omitempty"`
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Icon        *string `json:"icon,omitempty"`
	IconWeight  *string `json:"iconWeight,omitempty"`
	Id          *int    `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	PinnedBy    *[]struct {
		Id *int `json:"id,omitempty"`
	} `json:"pinnedBy,omitempty"`
	Tags *[]struct {
		Id   *int    `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"tags,omitempty"`
	Url *string `json:"url,omitempty"`
}

// PostApiV1MigrationMultipartBody defines parameters for PostApiV1Migration.
type PostApiV1MigrationMultipartBody struct {
	// Data The file to import. Should be in the specified format.
	Data openapi_types.File `json:"data"`

	// Format The format of the data to import.
	// - `0`: Linkwarden JSON format.
	// - `1`: HTML file format.
	// - `2`: Wallabag JSON format.
	Format PostApiV1MigrationMultipartBodyFormat `json:"format"`
}

// PostApiV1MigrationMultipartBodyFormat defines parameters for PostApiV1Migration.
type PostApiV1MigrationMultipartBodyFormat int

// GetApiV1PublicCollectionsLinksParams defines parameters for GetApiV1PublicCollectionsLinks.
type GetApiV1PublicCollectionsLinksParams struct {
	CollectionId        int     `form:"collectionId" json:"collectionId"`
	Sort                *int    `form:"sort,omitempty" json:"sort,omitempty"`
	Cursor              *int    `form:"cursor,omitempty" json:"cursor,omitempty"`
	PinnedOnly          *bool   `form:"pinnedOnly,omitempty" json:"pinnedOnly,omitempty"`
	SearchQueryString   *string `form:"searchQueryString,omitempty" json:"searchQueryString,omitempty"`
	SearchByName        *bool   `form:"searchByName,omitempty" json:"searchByName,omitempty"`
	SearchByUrl         *bool   `form:"searchByUrl,omitempty" json:"searchByUrl,omitempty"`
	SearchByDescription *bool   `form:"searchByDescription,omitempty" json:"searchByDescription,omitempty"`
	SearchByTextContent *bool   `form:"searchByTextContent,omitempty" json:"searchByTextContent,omitempty"`
	SearchByTags        *bool   `form:"searchByTags,omitempty" json:"searchByTags,omitempty"`
}

// GetApiV1PublicCollectionsTagsParams defines parameters for GetApiV1PublicCollectionsTags.
type GetApiV1PublicCollectionsTagsParams struct {
	// CollectionId The ID of the collection to retrieve tags for
	CollectionId int `form:"collectionId" json:"collectionId"`
}

// SearchLinksParams defines parameters for SearchLinks.
type SearchLinksParams struct {
	// SearchQueryString A string to filter search results.
	SearchQueryString *string `form:"searchQueryString,omitempty" json:"searchQueryString,omitempty"`

	// Sort A numeric value to sort the search results.
	Sort *int `form:"sort,omitempty" json:"sort,omitempty"`

	// Cursor A numeric value for pagination.
	Cursor *int `form:"cursor,omitempty" json:"cursor,omitempty"`

	// CollectionId Filter by collection ID
	CollectionId *int `form:"collectionId,omitempty" json:"collectionId,omitempty"`

	// TagId Filter by tag ID
	TagId *int `form:"tagId,omitempty" json:"tagId,omitempty"`
}

// PostApiV1SessionJSONBody defines parameters for PostApiV1Session.
type PostApiV1SessionJSONBody struct {
	// Password The password of the user.
	Password string `json:"password"`

	// SessionName A name for the session.
	SessionName string `json:"sessionName"`

	// Username The username of the user.
	Username string `json:"username"`
}

// UpdateTagJSONBody defines parameters for UpdateTag.
type UpdateTagJSONBody struct {
	Name *string `json:"name,omitempty"`
}

// CreateTokenJSONBody defines parameters for CreateToken.
type CreateTokenJSONBody struct {
	// Expires Expiry duration in seconds. Use 0 for no expiry.
	Expires int `json:"expires"`

	// Name Name of the token.
	Name string `json:"name"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	// Email The user's email address, optional based on environment variables.
	Email *openapi_types.Email `json:"email,omitempty"`

	// Invite Optional flag for invitations.
	Invite *bool `json:"invite,omitempty"`

	// Name The user's name.
	Name *string `json:"name,omitempty"`

	// Password The user's password, must be at least 8 characters long.
	Password *string `json:"password,omitempty"`

	// Username The user's username, optional if email is provided.
	Username *string `json:"username,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	ArchiveAsMonolith       *bool                           `json:"archiveAsMonolith"`
	ArchiveAsPDF            *bool                           `json:"archiveAsPDF"`
	ArchiveAsScreenshot     *bool                           `json:"archiveAsScreenshot"`
	ArchiveAsWaybackMachine *bool                           `json:"archiveAsWaybackMachine"`
	CollectionOrder         *[]int                          `json:"collectionOrder"`
	Email                   *openapi_types.Email            `json:"email"`
	Image                   *string                         `json:"image"`
	IsPrivate               *bool                           `json:"isPrivate"`
	LinksRouteTo            *UpdateUserJSONBodyLinksRouteTo `json:"linksRouteTo"`
	Locale                  *string                         `json:"locale"`
	Name                    *string                         `json:"name,omitempty"`
	NewPassword             *string                         `json:"newPassword"`
	OldPassword             *string                         `json:"oldPassword"`
	Password                *string                         `json:"password"`
	PreventDuplicateLinks   *bool                           `json:"preventDuplicateLinks"`
	ReferredBy              *string                         `json:"referredBy"`
	Username                *string                         `json:"username,omitempty"`
	WhitelistedUsers        *[]string                       `json:"whitelistedUsers"`
}

// UpdateUserJSONBodyLinksRouteTo defines parameters for UpdateUser.
type UpdateUserJSONBodyLinksRouteTo string

// PostApiV1ArchivesLinkIdMultipartRequestBody defines body for PostApiV1ArchivesLinkId for multipart/form-data ContentType.
type PostApiV1ArchivesLinkIdMultipartRequestBody PostApiV1ArchivesLinkIdMultipartBody

// PutApiV1ArchivesLinkIdMultipartRequestBody defines body for PutApiV1ArchivesLinkId for multipart/form-data ContentType.
type PutApiV1ArchivesLinkIdMultipartRequestBody PutApiV1ArchivesLinkIdMultipartBody

// PostApiV1AuthForgotPasswordJSONRequestBody defines body for PostApiV1AuthForgotPassword for application/json ContentType.
type PostApiV1AuthForgotPasswordJSONRequestBody PostApiV1AuthForgotPasswordJSONBody

// PostApiV1AuthResetPasswordJSONRequestBody defines body for PostApiV1AuthResetPassword for application/json ContentType.
type PostApiV1AuthResetPasswordJSONRequestBody PostApiV1AuthResetPasswordJSONBody

// CreateCollectionJSONRequestBody defines body for CreateCollection for application/json ContentType.
type CreateCollectionJSONRequestBody CreateCollectionJSONBody

// UpdateCollectionJSONRequestBody defines body for UpdateCollection for application/json ContentType.
type UpdateCollectionJSONRequestBody UpdateCollectionJSONBody

// DeleteLinksJSONRequestBody defines body for DeleteLinks for application/json ContentType.
type DeleteLinksJSONRequestBody DeleteLinksJSONBody

// CreateLinkJSONRequestBody defines body for CreateLink for application/json ContentType.
type CreateLinkJSONRequestBody CreateLinkJSONBody

// BulkUpdateLinksJSONRequestBody defines body for BulkUpdateLinks for application/json ContentType.
type BulkUpdateLinksJSONRequestBody BulkUpdateLinksJSONBody

// UpdateLinkJSONRequestBody defines body for UpdateLink for application/json ContentType.
type UpdateLinkJSONRequestBody UpdateLinkJSONBody

// PostApiV1MigrationMultipartRequestBody defines body for PostApiV1Migration for multipart/form-data ContentType.
type PostApiV1MigrationMultipartRequestBody PostApiV1MigrationMultipartBody

// PostApiV1SessionJSONRequestBody defines body for PostApiV1Session for application/json ContentType.
type PostApiV1SessionJSONRequestBody PostApiV1SessionJSONBody

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody UpdateTagJSONBody

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody CreateTokenJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetApiV1ArchivesLinkId request
	GetApiV1ArchivesLinkId(ctx context.Context, linkId string, params *GetApiV1ArchivesLinkIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiV1ArchivesLinkIdWithBody request with any body
	PostApiV1ArchivesLinkIdWithBody(ctx context.Context, linkId string, params *PostApiV1ArchivesLinkIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutApiV1ArchivesLinkIdWithBody request with any body
	PutApiV1ArchivesLinkIdWithBody(ctx context.Context, linkId string, params *PutApiV1ArchivesLinkIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiV1AuthForgotPasswordWithBody request with any body
	PostApiV1AuthForgotPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApiV1AuthForgotPassword(ctx context.Context, body PostApiV1AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiV1AuthResetPasswordWithBody request with any body
	PostApiV1AuthResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApiV1AuthResetPassword(ctx context.Context, body PostApiV1AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiV1AuthVerifyEmail request
	PostApiV1AuthVerifyEmail(ctx context.Context, params *PostApiV1AuthVerifyEmailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiV1AvatarId request
	GetApiV1AvatarId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCollections request
	GetAllCollections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCollectionWithBody request with any body
	CreateCollectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCollection(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollectionById request
	DeleteCollectionById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionById request
	GetCollectionById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCollectionWithBody request with any body
	UpdateCollectionWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCollection(ctx context.Context, id int, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDashboard request
	GetDashboard(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLinksWithBody request with any body
	DeleteLinksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLinks(ctx context.Context, body DeleteLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiV1Links request
	GetApiV1Links(ctx context.Context, params *GetApiV1LinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLinkWithBody request with any body
	CreateLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLink(ctx context.Context, body CreateLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateLinksWithBody request with any body
	BulkUpdateLinksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateLinks(ctx context.Context, body BulkUpdateLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLink request
	DeleteLink(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLink request
	GetLink(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLinkWithBody request with any body
	UpdateLinkWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLink(ctx context.Context, id int, body UpdateLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveLink request
	ArchiveLink(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoginConfiguration request
	GetLoginConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiV1Migration request
	GetApiV1Migration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiV1MigrationWithBody request with any body
	PostApiV1MigrationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiV1PublicCollectionsLinks request
	GetApiV1PublicCollectionsLinks(ctx context.Context, params *GetApiV1PublicCollectionsLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiV1PublicCollectionsTags request
	GetApiV1PublicCollectionsTags(ctx context.Context, params *GetApiV1PublicCollectionsTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiV1PublicCollectionsId request
	GetApiV1PublicCollectionsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiV1PublicLinksId request
	GetApiV1PublicLinksId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiV1PublicUsersId request
	GetApiV1PublicUsersId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchLinks request
	SearchLinks(ctx context.Context, params *SearchLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiV1SessionWithBody request with any body
	PostApiV1SessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApiV1Session(ctx context.Context, body PostApiV1SessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTagWithBody request with any body
	UpdateTagWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTag(ctx context.Context, id int, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokens request
	GetTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeToken request
	RevokeToken(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDashboardV2 request
	GetDashboardV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetApiV1ArchivesLinkId(ctx context.Context, linkId string, params *GetApiV1ArchivesLinkIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiV1ArchivesLinkIdRequest(c.Server, linkId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiV1ArchivesLinkIdWithBody(ctx context.Context, linkId string, params *PostApiV1ArchivesLinkIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiV1ArchivesLinkIdRequestWithBody(c.Server, linkId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutApiV1ArchivesLinkIdWithBody(ctx context.Context, linkId string, params *PutApiV1ArchivesLinkIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutApiV1ArchivesLinkIdRequestWithBody(c.Server, linkId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiV1AuthForgotPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiV1AuthForgotPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiV1AuthForgotPassword(ctx context.Context, body PostApiV1AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiV1AuthForgotPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiV1AuthResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiV1AuthResetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiV1AuthResetPassword(ctx context.Context, body PostApiV1AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiV1AuthResetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiV1AuthVerifyEmail(ctx context.Context, params *PostApiV1AuthVerifyEmailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiV1AuthVerifyEmailRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiV1AvatarId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiV1AvatarIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCollections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCollectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollection(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollectionById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollectionWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollection(ctx context.Context, id int, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDashboard(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDashboardRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLinksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLinksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLinks(ctx context.Context, body DeleteLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLinksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiV1Links(ctx context.Context, params *GetApiV1LinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiV1LinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLink(ctx context.Context, body CreateLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateLinksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateLinksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateLinks(ctx context.Context, body BulkUpdateLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateLinksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLink(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLinkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLink(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLinkWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLinkRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLink(ctx context.Context, id int, body UpdateLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLinkRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveLink(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveLinkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoginConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoginConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiV1Migration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiV1MigrationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiV1MigrationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiV1MigrationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiV1PublicCollectionsLinks(ctx context.Context, params *GetApiV1PublicCollectionsLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiV1PublicCollectionsLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiV1PublicCollectionsTags(ctx context.Context, params *GetApiV1PublicCollectionsTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiV1PublicCollectionsTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiV1PublicCollectionsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiV1PublicCollectionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiV1PublicLinksId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiV1PublicLinksIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiV1PublicUsersId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiV1PublicUsersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchLinks(ctx context.Context, params *SearchLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiV1SessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiV1SessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiV1Session(ctx context.Context, body PostApiV1SessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiV1SessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTagWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTag(ctx context.Context, id int, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokensRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeToken(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDashboardV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDashboardV2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetApiV1ArchivesLinkIdRequest generates requests for GetApiV1ArchivesLinkId
func NewGetApiV1ArchivesLinkIdRequest(server string, linkId string, params *GetApiV1ArchivesLinkIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "linkId", runtime.ParamLocationPath, linkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/archives/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preview != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preview", runtime.ParamLocationQuery, *params.Preview); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostApiV1ArchivesLinkIdRequestWithBody generates requests for PostApiV1ArchivesLinkId with any type of body
func NewPostApiV1ArchivesLinkIdRequestWithBody(server string, linkId string, params *PostApiV1ArchivesLinkIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "linkId", runtime.ParamLocationPath, linkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/archives/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutApiV1ArchivesLinkIdRequestWithBody generates requests for PutApiV1ArchivesLinkId with any type of body
func NewPutApiV1ArchivesLinkIdRequestWithBody(server string, linkId string, params *PutApiV1ArchivesLinkIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "linkId", runtime.ParamLocationPath, linkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/archives/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostApiV1AuthForgotPasswordRequest calls the generic PostApiV1AuthForgotPassword builder with application/json body
func NewPostApiV1AuthForgotPasswordRequest(server string, body PostApiV1AuthForgotPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApiV1AuthForgotPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewPostApiV1AuthForgotPasswordRequestWithBody generates requests for PostApiV1AuthForgotPassword with any type of body
func NewPostApiV1AuthForgotPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/forgot-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostApiV1AuthResetPasswordRequest calls the generic PostApiV1AuthResetPassword builder with application/json body
func NewPostApiV1AuthResetPasswordRequest(server string, body PostApiV1AuthResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApiV1AuthResetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewPostApiV1AuthResetPasswordRequestWithBody generates requests for PostApiV1AuthResetPassword with any type of body
func NewPostApiV1AuthResetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostApiV1AuthVerifyEmailRequest generates requests for PostApiV1AuthVerifyEmail
func NewPostApiV1AuthVerifyEmailRequest(server string, params *PostApiV1AuthVerifyEmailParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/verify-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiV1AvatarIdRequest generates requests for GetApiV1AvatarId
func NewGetApiV1AvatarIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/avatar/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllCollectionsRequest generates requests for GetAllCollections
func NewGetAllCollectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCollectionRequest calls the generic CreateCollection builder with application/json body
func NewCreateCollectionRequest(server string, body CreateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCollectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCollectionRequestWithBody generates requests for CreateCollection with any type of body
func NewCreateCollectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCollectionByIdRequest generates requests for DeleteCollectionById
func NewDeleteCollectionByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionByIdRequest generates requests for GetCollectionById
func NewGetCollectionByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCollectionRequest calls the generic UpdateCollection builder with application/json body
func NewUpdateCollectionRequest(server string, id int, body UpdateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCollectionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCollectionRequestWithBody generates requests for UpdateCollection with any type of body
func NewUpdateCollectionRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDashboardRequest generates requests for GetDashboard
func NewGetDashboardRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/dashboard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteLinksRequest calls the generic DeleteLinks builder with application/json body
func NewDeleteLinksRequest(server string, body DeleteLinksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLinksRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteLinksRequestWithBody generates requests for DeleteLinks with any type of body
func NewDeleteLinksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetApiV1LinksRequest generates requests for GetApiV1Links
func NewGetApiV1LinksRequest(server string, params *GetApiV1LinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollectionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collectionId", runtime.ParamLocationQuery, *params.CollectionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagId", runtime.ParamLocationQuery, *params.TagId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PinnedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pinnedOnly", runtime.ParamLocationQuery, *params.PinnedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchQueryString != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchQueryString", runtime.ParamLocationQuery, *params.SearchQueryString); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByName", runtime.ParamLocationQuery, *params.SearchByName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByUrl", runtime.ParamLocationQuery, *params.SearchByUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByDescription != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByDescription", runtime.ParamLocationQuery, *params.SearchByDescription); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByTextContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByTextContent", runtime.ParamLocationQuery, *params.SearchByTextContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByTags", runtime.ParamLocationQuery, *params.SearchByTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLinkRequest calls the generic CreateLink builder with application/json body
func NewCreateLinkRequest(server string, body CreateLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLinkRequestWithBody generates requests for CreateLink with any type of body
func NewCreateLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateLinksRequest calls the generic BulkUpdateLinks builder with application/json body
func NewBulkUpdateLinksRequest(server string, body BulkUpdateLinksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateLinksRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateLinksRequestWithBody generates requests for BulkUpdateLinks with any type of body
func NewBulkUpdateLinksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLinkRequest generates requests for DeleteLink
func NewDeleteLinkRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/links/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLinkRequest generates requests for GetLink
func NewGetLinkRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/links/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLinkRequest calls the generic UpdateLink builder with application/json body
func NewUpdateLinkRequest(server string, id int, body UpdateLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLinkRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateLinkRequestWithBody generates requests for UpdateLink with any type of body
func NewUpdateLinkRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/links/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveLinkRequest generates requests for ArchiveLink
func NewArchiveLinkRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/links/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoginConfigurationRequest generates requests for GetLoginConfiguration
func NewGetLoginConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/logins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiV1MigrationRequest generates requests for GetApiV1Migration
func NewGetApiV1MigrationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/migration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostApiV1MigrationRequestWithBody generates requests for PostApiV1Migration with any type of body
func NewPostApiV1MigrationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/migration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetApiV1PublicCollectionsLinksRequest generates requests for GetApiV1PublicCollectionsLinks
func NewGetApiV1PublicCollectionsLinksRequest(server string, params *GetApiV1PublicCollectionsLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/public/collections/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collectionId", runtime.ParamLocationQuery, params.CollectionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PinnedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pinnedOnly", runtime.ParamLocationQuery, *params.PinnedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchQueryString != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchQueryString", runtime.ParamLocationQuery, *params.SearchQueryString); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByName", runtime.ParamLocationQuery, *params.SearchByName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByUrl", runtime.ParamLocationQuery, *params.SearchByUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByDescription != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByDescription", runtime.ParamLocationQuery, *params.SearchByDescription); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByTextContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByTextContent", runtime.ParamLocationQuery, *params.SearchByTextContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchByTags", runtime.ParamLocationQuery, *params.SearchByTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiV1PublicCollectionsTagsRequest generates requests for GetApiV1PublicCollectionsTags
func NewGetApiV1PublicCollectionsTagsRequest(server string, params *GetApiV1PublicCollectionsTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/public/collections/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collectionId", runtime.ParamLocationQuery, params.CollectionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiV1PublicCollectionsIdRequest generates requests for GetApiV1PublicCollectionsId
func NewGetApiV1PublicCollectionsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/public/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiV1PublicLinksIdRequest generates requests for GetApiV1PublicLinksId
func NewGetApiV1PublicLinksIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/public/links/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiV1PublicUsersIdRequest generates requests for GetApiV1PublicUsersId
func NewGetApiV1PublicUsersIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/public/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchLinksRequest generates requests for SearchLinks
func NewSearchLinksRequest(server string, params *SearchLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SearchQueryString != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchQueryString", runtime.ParamLocationQuery, *params.SearchQueryString); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollectionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collectionId", runtime.ParamLocationQuery, *params.CollectionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagId", runtime.ParamLocationQuery, *params.TagId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostApiV1SessionRequest calls the generic PostApiV1Session builder with application/json body
func NewPostApiV1SessionRequest(server string, body PostApiV1SessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApiV1SessionRequestWithBody(server, "application/json", bodyReader)
}

// NewPostApiV1SessionRequestWithBody generates requests for PostApiV1Session with any type of body
func NewPostApiV1SessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTagRequest calls the generic UpdateTag builder with application/json body
func NewUpdateTagRequest(server string, id int, body UpdateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTagRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateTagRequestWithBody generates requests for UpdateTag with any type of body
func NewUpdateTagRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTokensRequest generates requests for GetTokens
func NewGetTokensRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeTokenRequest generates requests for RevokeToken
func NewRevokeTokenRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, id int, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDashboardV2Request generates requests for GetDashboardV2
func NewGetDashboardV2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/dashboard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetApiV1ArchivesLinkIdWithResponse request
	GetApiV1ArchivesLinkIdWithResponse(ctx context.Context, linkId string, params *GetApiV1ArchivesLinkIdParams, reqEditors ...RequestEditorFn) (*GetApiV1ArchivesLinkIdResponse, error)

	// PostApiV1ArchivesLinkIdWithBodyWithResponse request with any body
	PostApiV1ArchivesLinkIdWithBodyWithResponse(ctx context.Context, linkId string, params *PostApiV1ArchivesLinkIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1ArchivesLinkIdResponse, error)

	// PutApiV1ArchivesLinkIdWithBodyWithResponse request with any body
	PutApiV1ArchivesLinkIdWithBodyWithResponse(ctx context.Context, linkId string, params *PutApiV1ArchivesLinkIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutApiV1ArchivesLinkIdResponse, error)

	// PostApiV1AuthForgotPasswordWithBodyWithResponse request with any body
	PostApiV1AuthForgotPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1AuthForgotPasswordResponse, error)

	PostApiV1AuthForgotPasswordWithResponse(ctx context.Context, body PostApiV1AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiV1AuthForgotPasswordResponse, error)

	// PostApiV1AuthResetPasswordWithBodyWithResponse request with any body
	PostApiV1AuthResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1AuthResetPasswordResponse, error)

	PostApiV1AuthResetPasswordWithResponse(ctx context.Context, body PostApiV1AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiV1AuthResetPasswordResponse, error)

	// PostApiV1AuthVerifyEmailWithResponse request
	PostApiV1AuthVerifyEmailWithResponse(ctx context.Context, params *PostApiV1AuthVerifyEmailParams, reqEditors ...RequestEditorFn) (*PostApiV1AuthVerifyEmailResponse, error)

	// GetApiV1AvatarIdWithResponse request
	GetApiV1AvatarIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetApiV1AvatarIdResponse, error)

	// GetAllCollectionsWithResponse request
	GetAllCollectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCollectionsResponse, error)

	// CreateCollectionWithBodyWithResponse request with any body
	CreateCollectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	CreateCollectionWithResponse(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	// DeleteCollectionByIdWithResponse request
	DeleteCollectionByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteCollectionByIdResponse, error)

	// GetCollectionByIdWithResponse request
	GetCollectionByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCollectionByIdResponse, error)

	// UpdateCollectionWithBodyWithResponse request with any body
	UpdateCollectionWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error)

	UpdateCollectionWithResponse(ctx context.Context, id int, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error)

	// GetDashboardWithResponse request
	GetDashboardWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDashboardResponse, error)

	// DeleteLinksWithBodyWithResponse request with any body
	DeleteLinksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLinksResponse, error)

	DeleteLinksWithResponse(ctx context.Context, body DeleteLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLinksResponse, error)

	// GetApiV1LinksWithResponse request
	GetApiV1LinksWithResponse(ctx context.Context, params *GetApiV1LinksParams, reqEditors ...RequestEditorFn) (*GetApiV1LinksResponse, error)

	// CreateLinkWithBodyWithResponse request with any body
	CreateLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLinkResponse, error)

	CreateLinkWithResponse(ctx context.Context, body CreateLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLinkResponse, error)

	// BulkUpdateLinksWithBodyWithResponse request with any body
	BulkUpdateLinksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateLinksResponse, error)

	BulkUpdateLinksWithResponse(ctx context.Context, body BulkUpdateLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateLinksResponse, error)

	// DeleteLinkWithResponse request
	DeleteLinkWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteLinkResponse, error)

	// GetLinkWithResponse request
	GetLinkWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetLinkResponse, error)

	// UpdateLinkWithBodyWithResponse request with any body
	UpdateLinkWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLinkResponse, error)

	UpdateLinkWithResponse(ctx context.Context, id int, body UpdateLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLinkResponse, error)

	// ArchiveLinkWithResponse request
	ArchiveLinkWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ArchiveLinkResponse, error)

	// GetLoginConfigurationWithResponse request
	GetLoginConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoginConfigurationResponse, error)

	// GetApiV1MigrationWithResponse request
	GetApiV1MigrationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiV1MigrationResponse, error)

	// PostApiV1MigrationWithBodyWithResponse request with any body
	PostApiV1MigrationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1MigrationResponse, error)

	// GetApiV1PublicCollectionsLinksWithResponse request
	GetApiV1PublicCollectionsLinksWithResponse(ctx context.Context, params *GetApiV1PublicCollectionsLinksParams, reqEditors ...RequestEditorFn) (*GetApiV1PublicCollectionsLinksResponse, error)

	// GetApiV1PublicCollectionsTagsWithResponse request
	GetApiV1PublicCollectionsTagsWithResponse(ctx context.Context, params *GetApiV1PublicCollectionsTagsParams, reqEditors ...RequestEditorFn) (*GetApiV1PublicCollectionsTagsResponse, error)

	// GetApiV1PublicCollectionsIdWithResponse request
	GetApiV1PublicCollectionsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetApiV1PublicCollectionsIdResponse, error)

	// GetApiV1PublicLinksIdWithResponse request
	GetApiV1PublicLinksIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetApiV1PublicLinksIdResponse, error)

	// GetApiV1PublicUsersIdWithResponse request
	GetApiV1PublicUsersIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetApiV1PublicUsersIdResponse, error)

	// SearchLinksWithResponse request
	SearchLinksWithResponse(ctx context.Context, params *SearchLinksParams, reqEditors ...RequestEditorFn) (*SearchLinksResponse, error)

	// PostApiV1SessionWithBodyWithResponse request with any body
	PostApiV1SessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1SessionResponse, error)

	PostApiV1SessionWithResponse(ctx context.Context, body PostApiV1SessionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiV1SessionResponse, error)

	// GetTagsWithResponse request
	GetTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// DeleteTagWithResponse request
	DeleteTagWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// UpdateTagWithBodyWithResponse request with any body
	UpdateTagWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	UpdateTagWithResponse(ctx context.Context, id int, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	// GetTokensWithResponse request
	GetTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokensResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// RevokeTokenWithResponse request
	RevokeTokenWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// GetDashboardV2WithResponse request
	GetDashboardV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDashboardV2Response, error)
}

type GetApiV1ArchivesLinkIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response The archive file.
		Response *map[string]interface{} `json:"response,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *struct {
		Response *string `json:"response,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetApiV1ArchivesLinkIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiV1ArchivesLinkIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiV1ArchivesLinkIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Details about the uploaded file.
		Response *map[string]interface{} `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r PostApiV1ArchivesLinkIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiV1ArchivesLinkIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutApiV1ArchivesLinkIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response Updated details of the archive.
		Response *map[string]interface{} `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r PutApiV1ArchivesLinkIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutApiV1ArchivesLinkIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiV1AuthForgotPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *string `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON404 *struct {
		Response *string `json:"response,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostApiV1AuthForgotPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiV1AuthForgotPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiV1AuthResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *string `json:"response,omitempty"`
	}
	JSON400 *BadRequest
}

// Status returns HTTPResponse.Status
func (r PostApiV1AuthResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiV1AuthResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiV1AuthVerifyEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *string `json:"response,omitempty"`
	}
	JSON400 *BadRequest
}

// Status returns HTTPResponse.Status
func (r PostApiV1AuthVerifyEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiV1AuthVerifyEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiV1AvatarIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetApiV1AvatarIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiV1AvatarIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionsResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetAllCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response The deleted collection details.
		Response *struct {
			Color       *string    `json:"color,omitempty"`
			CreatedAt   *time.Time `json:"createdAt,omitempty"`
			CreatedById *int       `json:"createdById,omitempty"`
			Description *string    `json:"description,omitempty"`
			Icon        *string    `json:"icon"`
			IconWeight  *string    `json:"iconWeight"`
			Id          *int       `json:"id,omitempty"`
			IsPublic    *bool      `json:"isPublic,omitempty"`
			Name        *string    `json:"name,omitempty"`
			OwnerId     *int       `json:"ownerId,omitempty"`
			ParentId    *int       `json:"parentId"`
			UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
		} `json:"response,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionResponse
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetCollectionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DashboardResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *struct {
			Count *int `json:"count,omitempty"`
		} `json:"response,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiV1LinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinksResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetApiV1LinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiV1LinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *string `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r BulkUpdateLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *struct {
			CollectionId  *float32   `json:"collectionId,omitempty"`
			Color         *string    `json:"color"`
			CreatedAt     *time.Time `json:"createdAt,omitempty"`
			CreatedById   *float32   `json:"createdById,omitempty"`
			Description   *string    `json:"description,omitempty"`
			Icon          *string    `json:"icon"`
			IconWeight    *string    `json:"iconWeight"`
			Id            *int       `json:"id,omitempty"`
			Image         *string    `json:"image"`
			ImportDate    *time.Time `json:"importDate"`
			LastPreserved *time.Time `json:"lastPreserved"`
			Monolith      *string    `json:"monolith"`
			Name          *string    `json:"name,omitempty"`
			Pdf           *string    `json:"pdf"`
			Preview       *string    `json:"preview"`
			Readable      *string    `json:"readable"`
			TextContent   *string    `json:"textContent"`
			Type          *string    `json:"type,omitempty"`
			UpdatedAt     *time.Time `json:"updatedAt,omitempty"`
			Url           *string    `json:"url,omitempty"`
		} `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *string `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r ArchiveLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoginConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginConfigResponse
}

// Status returns HTTPResponse.Status
func (r GetLoginConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoginConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiV1MigrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MigrationResponse
	JSON401      *Unauthorized
	JSON404      *struct {
		Response *string `json:"response,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetApiV1MigrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiV1MigrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiV1MigrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response The response message for the import.
		Response *string `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r PostApiV1MigrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiV1MigrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiV1PublicCollectionsLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *[]struct {
			CollectionId  *int                                                 `json:"collectionId,omitempty"`
			Color         *string                                              `json:"color,omitempty"`
			CreatedAt     *time.Time                                           `json:"createdAt,omitempty"`
			CreatedById   *int                                                 `json:"createdById,omitempty"`
			Description   *string                                              `json:"description,omitempty"`
			Icon          *string                                              `json:"icon"`
			IconWeight    *GetApiV1PublicCollectionsLinks200ResponseIconWeight `json:"iconWeight"`
			Id            *int                                                 `json:"id,omitempty"`
			Image         *string                                              `json:"image"`
			ImportDate    *string                                              `json:"importDate"`
			LastPreserved *time.Time                                           `json:"lastPreserved"`
			Monolith      *string                                              `json:"monolith"`
			Name          *string                                              `json:"name,omitempty"`
			Pdf           *string                                              `json:"pdf"`
			Preview       *string                                              `json:"preview"`
			Readable      *string                                              `json:"readable"`
			Tags          *[]struct {
				CreatedAt *time.Time `json:"createdAt,omitempty"`
				Id        *int       `json:"id,omitempty"`
				Name      *string    `json:"name,omitempty"`
				OwnerId   *int       `json:"ownerId,omitempty"`
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"tags,omitempty"`
			TextContent *string    `json:"textContent"`
			Type        *string    `json:"type,omitempty"`
			UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
			Url         *string    `json:"url,omitempty"`
		} `json:"response,omitempty"`
	}
	JSON400 *BadRequest
}
type GetApiV1PublicCollectionsLinks200ResponseIconWeight string

// Status returns HTTPResponse.Status
func (r GetApiV1PublicCollectionsLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiV1PublicCollectionsLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiV1PublicCollectionsTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *[]struct {
			CreatedAt *time.Time `json:"createdAt,omitempty"`
			Id        *int       `json:"id,omitempty"`
			Name      *string    `json:"name,omitempty"`
			OwnerId   *int       `json:"ownerId,omitempty"`
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`
		} `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON404 *struct {
		Response *string `json:"response,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetApiV1PublicCollectionsTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiV1PublicCollectionsTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiV1PublicCollectionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetApiV1PublicCollectionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiV1PublicCollectionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiV1PublicLinksIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkResponse
}

// Status returns HTTPResponse.Status
func (r GetApiV1PublicLinksIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiV1PublicLinksIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiV1PublicUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicUserResponse
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetApiV1PublicUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiV1PublicUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r SearchLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiV1SessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionResponse
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r PostApiV1SessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiV1SessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagsResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokensResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateTokenData
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r RevokeTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *string `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Response *struct {
			ArchiveAsMonolith       *bool      `json:"archiveAsMonolith,omitempty"`
			ArchiveAsPDF            *bool      `json:"archiveAsPDF,omitempty"`
			ArchiveAsScreenshot     *bool      `json:"archiveAsScreenshot,omitempty"`
			ArchiveAsWaybackMachine *bool      `json:"archiveAsWaybackMachine,omitempty"`
			CollectionOrder         *[]int     `json:"collectionOrder,omitempty"`
			CreatedAt               *time.Time `json:"createdAt,omitempty"`
			Email                   *string    `json:"email"`
			EmailVerified           *string    `json:"emailVerified"`
			Id                      *int       `json:"id,omitempty"`
			Image                   *string    `json:"image,omitempty"`
			IsPrivate               *bool      `json:"isPrivate,omitempty"`
			LinksRouteTo            *string    `json:"linksRouteTo,omitempty"`
			Locale                  *string    `json:"locale,omitempty"`
			Name                    *string    `json:"name,omitempty"`
			ParentSubscription      *struct {
				User *map[string]interface{} `json:"user"`
			} `json:"parentSubscription"`
			PreventDuplicateLinks *bool                   `json:"preventDuplicateLinks,omitempty"`
			ReferredBy            *string                 `json:"referredBy"`
			Subscription          *map[string]interface{} `json:"subscription"`
			UpdatedAt             *time.Time              `json:"updatedAt,omitempty"`
			Username              *string                 `json:"username,omitempty"`
			WhitelistedUsers      *[]string               `json:"whitelistedUsers,omitempty"`
		} `json:"response,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDashboardV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DashboardV2Response
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetDashboardV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDashboardV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetApiV1ArchivesLinkIdWithResponse request returning *GetApiV1ArchivesLinkIdResponse
func (c *ClientWithResponses) GetApiV1ArchivesLinkIdWithResponse(ctx context.Context, linkId string, params *GetApiV1ArchivesLinkIdParams, reqEditors ...RequestEditorFn) (*GetApiV1ArchivesLinkIdResponse, error) {
	rsp, err := c.GetApiV1ArchivesLinkId(ctx, linkId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiV1ArchivesLinkIdResponse(rsp)
}

// PostApiV1ArchivesLinkIdWithBodyWithResponse request with arbitrary body returning *PostApiV1ArchivesLinkIdResponse
func (c *ClientWithResponses) PostApiV1ArchivesLinkIdWithBodyWithResponse(ctx context.Context, linkId string, params *PostApiV1ArchivesLinkIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1ArchivesLinkIdResponse, error) {
	rsp, err := c.PostApiV1ArchivesLinkIdWithBody(ctx, linkId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiV1ArchivesLinkIdResponse(rsp)
}

// PutApiV1ArchivesLinkIdWithBodyWithResponse request with arbitrary body returning *PutApiV1ArchivesLinkIdResponse
func (c *ClientWithResponses) PutApiV1ArchivesLinkIdWithBodyWithResponse(ctx context.Context, linkId string, params *PutApiV1ArchivesLinkIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutApiV1ArchivesLinkIdResponse, error) {
	rsp, err := c.PutApiV1ArchivesLinkIdWithBody(ctx, linkId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutApiV1ArchivesLinkIdResponse(rsp)
}

// PostApiV1AuthForgotPasswordWithBodyWithResponse request with arbitrary body returning *PostApiV1AuthForgotPasswordResponse
func (c *ClientWithResponses) PostApiV1AuthForgotPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1AuthForgotPasswordResponse, error) {
	rsp, err := c.PostApiV1AuthForgotPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiV1AuthForgotPasswordResponse(rsp)
}

func (c *ClientWithResponses) PostApiV1AuthForgotPasswordWithResponse(ctx context.Context, body PostApiV1AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiV1AuthForgotPasswordResponse, error) {
	rsp, err := c.PostApiV1AuthForgotPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiV1AuthForgotPasswordResponse(rsp)
}

// PostApiV1AuthResetPasswordWithBodyWithResponse request with arbitrary body returning *PostApiV1AuthResetPasswordResponse
func (c *ClientWithResponses) PostApiV1AuthResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1AuthResetPasswordResponse, error) {
	rsp, err := c.PostApiV1AuthResetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiV1AuthResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) PostApiV1AuthResetPasswordWithResponse(ctx context.Context, body PostApiV1AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiV1AuthResetPasswordResponse, error) {
	rsp, err := c.PostApiV1AuthResetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiV1AuthResetPasswordResponse(rsp)
}

// PostApiV1AuthVerifyEmailWithResponse request returning *PostApiV1AuthVerifyEmailResponse
func (c *ClientWithResponses) PostApiV1AuthVerifyEmailWithResponse(ctx context.Context, params *PostApiV1AuthVerifyEmailParams, reqEditors ...RequestEditorFn) (*PostApiV1AuthVerifyEmailResponse, error) {
	rsp, err := c.PostApiV1AuthVerifyEmail(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiV1AuthVerifyEmailResponse(rsp)
}

// GetApiV1AvatarIdWithResponse request returning *GetApiV1AvatarIdResponse
func (c *ClientWithResponses) GetApiV1AvatarIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetApiV1AvatarIdResponse, error) {
	rsp, err := c.GetApiV1AvatarId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiV1AvatarIdResponse(rsp)
}

// GetAllCollectionsWithResponse request returning *GetAllCollectionsResponse
func (c *ClientWithResponses) GetAllCollectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCollectionsResponse, error) {
	rsp, err := c.GetAllCollections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCollectionsResponse(rsp)
}

// CreateCollectionWithBodyWithResponse request with arbitrary body returning *CreateCollectionResponse
func (c *ClientWithResponses) CreateCollectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

func (c *ClientWithResponses) CreateCollectionWithResponse(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

// DeleteCollectionByIdWithResponse request returning *DeleteCollectionByIdResponse
func (c *ClientWithResponses) DeleteCollectionByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteCollectionByIdResponse, error) {
	rsp, err := c.DeleteCollectionById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionByIdResponse(rsp)
}

// GetCollectionByIdWithResponse request returning *GetCollectionByIdResponse
func (c *ClientWithResponses) GetCollectionByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCollectionByIdResponse, error) {
	rsp, err := c.GetCollectionById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionByIdResponse(rsp)
}

// UpdateCollectionWithBodyWithResponse request with arbitrary body returning *UpdateCollectionResponse
func (c *ClientWithResponses) UpdateCollectionWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error) {
	rsp, err := c.UpdateCollectionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateCollectionWithResponse(ctx context.Context, id int, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error) {
	rsp, err := c.UpdateCollection(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionResponse(rsp)
}

// GetDashboardWithResponse request returning *GetDashboardResponse
func (c *ClientWithResponses) GetDashboardWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDashboardResponse, error) {
	rsp, err := c.GetDashboard(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDashboardResponse(rsp)
}

// DeleteLinksWithBodyWithResponse request with arbitrary body returning *DeleteLinksResponse
func (c *ClientWithResponses) DeleteLinksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLinksResponse, error) {
	rsp, err := c.DeleteLinksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLinksResponse(rsp)
}

func (c *ClientWithResponses) DeleteLinksWithResponse(ctx context.Context, body DeleteLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLinksResponse, error) {
	rsp, err := c.DeleteLinks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLinksResponse(rsp)
}

// GetApiV1LinksWithResponse request returning *GetApiV1LinksResponse
func (c *ClientWithResponses) GetApiV1LinksWithResponse(ctx context.Context, params *GetApiV1LinksParams, reqEditors ...RequestEditorFn) (*GetApiV1LinksResponse, error) {
	rsp, err := c.GetApiV1Links(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiV1LinksResponse(rsp)
}

// CreateLinkWithBodyWithResponse request with arbitrary body returning *CreateLinkResponse
func (c *ClientWithResponses) CreateLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLinkResponse, error) {
	rsp, err := c.CreateLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLinkResponse(rsp)
}

func (c *ClientWithResponses) CreateLinkWithResponse(ctx context.Context, body CreateLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLinkResponse, error) {
	rsp, err := c.CreateLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLinkResponse(rsp)
}

// BulkUpdateLinksWithBodyWithResponse request with arbitrary body returning *BulkUpdateLinksResponse
func (c *ClientWithResponses) BulkUpdateLinksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateLinksResponse, error) {
	rsp, err := c.BulkUpdateLinksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateLinksResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateLinksWithResponse(ctx context.Context, body BulkUpdateLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateLinksResponse, error) {
	rsp, err := c.BulkUpdateLinks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateLinksResponse(rsp)
}

// DeleteLinkWithResponse request returning *DeleteLinkResponse
func (c *ClientWithResponses) DeleteLinkWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteLinkResponse, error) {
	rsp, err := c.DeleteLink(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLinkResponse(rsp)
}

// GetLinkWithResponse request returning *GetLinkResponse
func (c *ClientWithResponses) GetLinkWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetLinkResponse, error) {
	rsp, err := c.GetLink(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkResponse(rsp)
}

// UpdateLinkWithBodyWithResponse request with arbitrary body returning *UpdateLinkResponse
func (c *ClientWithResponses) UpdateLinkWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLinkResponse, error) {
	rsp, err := c.UpdateLinkWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLinkResponse(rsp)
}

func (c *ClientWithResponses) UpdateLinkWithResponse(ctx context.Context, id int, body UpdateLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLinkResponse, error) {
	rsp, err := c.UpdateLink(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLinkResponse(rsp)
}

// ArchiveLinkWithResponse request returning *ArchiveLinkResponse
func (c *ClientWithResponses) ArchiveLinkWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*ArchiveLinkResponse, error) {
	rsp, err := c.ArchiveLink(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveLinkResponse(rsp)
}

// GetLoginConfigurationWithResponse request returning *GetLoginConfigurationResponse
func (c *ClientWithResponses) GetLoginConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoginConfigurationResponse, error) {
	rsp, err := c.GetLoginConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoginConfigurationResponse(rsp)
}

// GetApiV1MigrationWithResponse request returning *GetApiV1MigrationResponse
func (c *ClientWithResponses) GetApiV1MigrationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiV1MigrationResponse, error) {
	rsp, err := c.GetApiV1Migration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiV1MigrationResponse(rsp)
}

// PostApiV1MigrationWithBodyWithResponse request with arbitrary body returning *PostApiV1MigrationResponse
func (c *ClientWithResponses) PostApiV1MigrationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1MigrationResponse, error) {
	rsp, err := c.PostApiV1MigrationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiV1MigrationResponse(rsp)
}

// GetApiV1PublicCollectionsLinksWithResponse request returning *GetApiV1PublicCollectionsLinksResponse
func (c *ClientWithResponses) GetApiV1PublicCollectionsLinksWithResponse(ctx context.Context, params *GetApiV1PublicCollectionsLinksParams, reqEditors ...RequestEditorFn) (*GetApiV1PublicCollectionsLinksResponse, error) {
	rsp, err := c.GetApiV1PublicCollectionsLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiV1PublicCollectionsLinksResponse(rsp)
}

// GetApiV1PublicCollectionsTagsWithResponse request returning *GetApiV1PublicCollectionsTagsResponse
func (c *ClientWithResponses) GetApiV1PublicCollectionsTagsWithResponse(ctx context.Context, params *GetApiV1PublicCollectionsTagsParams, reqEditors ...RequestEditorFn) (*GetApiV1PublicCollectionsTagsResponse, error) {
	rsp, err := c.GetApiV1PublicCollectionsTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiV1PublicCollectionsTagsResponse(rsp)
}

// GetApiV1PublicCollectionsIdWithResponse request returning *GetApiV1PublicCollectionsIdResponse
func (c *ClientWithResponses) GetApiV1PublicCollectionsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetApiV1PublicCollectionsIdResponse, error) {
	rsp, err := c.GetApiV1PublicCollectionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiV1PublicCollectionsIdResponse(rsp)
}

// GetApiV1PublicLinksIdWithResponse request returning *GetApiV1PublicLinksIdResponse
func (c *ClientWithResponses) GetApiV1PublicLinksIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetApiV1PublicLinksIdResponse, error) {
	rsp, err := c.GetApiV1PublicLinksId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiV1PublicLinksIdResponse(rsp)
}

// GetApiV1PublicUsersIdWithResponse request returning *GetApiV1PublicUsersIdResponse
func (c *ClientWithResponses) GetApiV1PublicUsersIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetApiV1PublicUsersIdResponse, error) {
	rsp, err := c.GetApiV1PublicUsersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiV1PublicUsersIdResponse(rsp)
}

// SearchLinksWithResponse request returning *SearchLinksResponse
func (c *ClientWithResponses) SearchLinksWithResponse(ctx context.Context, params *SearchLinksParams, reqEditors ...RequestEditorFn) (*SearchLinksResponse, error) {
	rsp, err := c.SearchLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchLinksResponse(rsp)
}

// PostApiV1SessionWithBodyWithResponse request with arbitrary body returning *PostApiV1SessionResponse
func (c *ClientWithResponses) PostApiV1SessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiV1SessionResponse, error) {
	rsp, err := c.PostApiV1SessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiV1SessionResponse(rsp)
}

func (c *ClientWithResponses) PostApiV1SessionWithResponse(ctx context.Context, body PostApiV1SessionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiV1SessionResponse, error) {
	rsp, err := c.PostApiV1Session(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiV1SessionResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// UpdateTagWithBodyWithResponse request with arbitrary body returning *UpdateTagResponse
func (c *ClientWithResponses) UpdateTagWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTagWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

func (c *ClientWithResponses) UpdateTagWithResponse(ctx context.Context, id int, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTag(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

// GetTokensWithResponse request returning *GetTokensResponse
func (c *ClientWithResponses) GetTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTokensResponse, error) {
	rsp, err := c.GetTokens(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokensResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// RevokeTokenWithResponse request returning *RevokeTokenResponse
func (c *ClientWithResponses) RevokeTokenWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error) {
	rsp, err := c.RevokeToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeTokenResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, id int, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// GetDashboardV2WithResponse request returning *GetDashboardV2Response
func (c *ClientWithResponses) GetDashboardV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDashboardV2Response, error) {
	rsp, err := c.GetDashboardV2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDashboardV2Response(rsp)
}

// ParseGetApiV1ArchivesLinkIdResponse parses an HTTP response from a GetApiV1ArchivesLinkIdWithResponse call
func ParseGetApiV1ArchivesLinkIdResponse(rsp *http.Response) (*GetApiV1ArchivesLinkIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiV1ArchivesLinkIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response The archive file.
			Response *map[string]interface{} `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostApiV1ArchivesLinkIdResponse parses an HTTP response from a PostApiV1ArchivesLinkIdWithResponse call
func ParsePostApiV1ArchivesLinkIdResponse(rsp *http.Response) (*PostApiV1ArchivesLinkIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiV1ArchivesLinkIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Details about the uploaded file.
			Response *map[string]interface{} `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePutApiV1ArchivesLinkIdResponse parses an HTTP response from a PutApiV1ArchivesLinkIdWithResponse call
func ParsePutApiV1ArchivesLinkIdResponse(rsp *http.Response) (*PutApiV1ArchivesLinkIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutApiV1ArchivesLinkIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response Updated details of the archive.
			Response *map[string]interface{} `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePostApiV1AuthForgotPasswordResponse parses an HTTP response from a PostApiV1AuthForgotPasswordWithResponse call
func ParsePostApiV1AuthForgotPasswordResponse(rsp *http.Response) (*PostApiV1AuthForgotPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiV1AuthForgotPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostApiV1AuthResetPasswordResponse parses an HTTP response from a PostApiV1AuthResetPasswordWithResponse call
func ParsePostApiV1AuthResetPasswordResponse(rsp *http.Response) (*PostApiV1AuthResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiV1AuthResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostApiV1AuthVerifyEmailResponse parses an HTTP response from a PostApiV1AuthVerifyEmailWithResponse call
func ParsePostApiV1AuthVerifyEmailResponse(rsp *http.Response) (*PostApiV1AuthVerifyEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiV1AuthVerifyEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetApiV1AvatarIdResponse parses an HTTP response from a GetApiV1AvatarIdWithResponse call
func ParseGetApiV1AvatarIdResponse(rsp *http.Response) (*GetApiV1AvatarIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiV1AvatarIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAllCollectionsResponse parses an HTTP response from a GetAllCollectionsWithResponse call
func ParseGetAllCollectionsResponse(rsp *http.Response) (*GetAllCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateCollectionResponse parses an HTTP response from a CreateCollectionWithResponse call
func ParseCreateCollectionResponse(rsp *http.Response) (*CreateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteCollectionByIdResponse parses an HTTP response from a DeleteCollectionByIdWithResponse call
func ParseDeleteCollectionByIdResponse(rsp *http.Response) (*DeleteCollectionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response The deleted collection details.
			Response *struct {
				Color       *string    `json:"color,omitempty"`
				CreatedAt   *time.Time `json:"createdAt,omitempty"`
				CreatedById *int       `json:"createdById,omitempty"`
				Description *string    `json:"description,omitempty"`
				Icon        *string    `json:"icon"`
				IconWeight  *string    `json:"iconWeight"`
				Id          *int       `json:"id,omitempty"`
				IsPublic    *bool      `json:"isPublic,omitempty"`
				Name        *string    `json:"name,omitempty"`
				OwnerId     *int       `json:"ownerId,omitempty"`
				ParentId    *int       `json:"parentId"`
				UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
			} `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetCollectionByIdResponse parses an HTTP response from a GetCollectionByIdWithResponse call
func ParseGetCollectionByIdResponse(rsp *http.Response) (*GetCollectionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateCollectionResponse parses an HTTP response from a UpdateCollectionWithResponse call
func ParseUpdateCollectionResponse(rsp *http.Response) (*UpdateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetDashboardResponse parses an HTTP response from a GetDashboardWithResponse call
func ParseGetDashboardResponse(rsp *http.Response) (*GetDashboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DashboardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteLinksResponse parses an HTTP response from a DeleteLinksWithResponse call
func ParseDeleteLinksResponse(rsp *http.Response) (*DeleteLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *struct {
				Count *int `json:"count,omitempty"`
			} `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetApiV1LinksResponse parses an HTTP response from a GetApiV1LinksWithResponse call
func ParseGetApiV1LinksResponse(rsp *http.Response) (*GetApiV1LinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiV1LinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateLinkResponse parses an HTTP response from a CreateLinkWithResponse call
func ParseCreateLinkResponse(rsp *http.Response) (*CreateLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseBulkUpdateLinksResponse parses an HTTP response from a BulkUpdateLinksWithResponse call
func ParseBulkUpdateLinksResponse(rsp *http.Response) (*BulkUpdateLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteLinkResponse parses an HTTP response from a DeleteLinkWithResponse call
func ParseDeleteLinkResponse(rsp *http.Response) (*DeleteLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *struct {
				CollectionId  *float32   `json:"collectionId,omitempty"`
				Color         *string    `json:"color"`
				CreatedAt     *time.Time `json:"createdAt,omitempty"`
				CreatedById   *float32   `json:"createdById,omitempty"`
				Description   *string    `json:"description,omitempty"`
				Icon          *string    `json:"icon"`
				IconWeight    *string    `json:"iconWeight"`
				Id            *int       `json:"id,omitempty"`
				Image         *string    `json:"image"`
				ImportDate    *time.Time `json:"importDate"`
				LastPreserved *time.Time `json:"lastPreserved"`
				Monolith      *string    `json:"monolith"`
				Name          *string    `json:"name,omitempty"`
				Pdf           *string    `json:"pdf"`
				Preview       *string    `json:"preview"`
				Readable      *string    `json:"readable"`
				TextContent   *string    `json:"textContent"`
				Type          *string    `json:"type,omitempty"`
				UpdatedAt     *time.Time `json:"updatedAt,omitempty"`
				Url           *string    `json:"url,omitempty"`
			} `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLinkResponse parses an HTTP response from a GetLinkWithResponse call
func ParseGetLinkResponse(rsp *http.Response) (*GetLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateLinkResponse parses an HTTP response from a UpdateLinkWithResponse call
func ParseUpdateLinkResponse(rsp *http.Response) (*UpdateLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseArchiveLinkResponse parses an HTTP response from a ArchiveLinkWithResponse call
func ParseArchiveLinkResponse(rsp *http.Response) (*ArchiveLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLoginConfigurationResponse parses an HTTP response from a GetLoginConfigurationWithResponse call
func ParseGetLoginConfigurationResponse(rsp *http.Response) (*GetLoginConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoginConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApiV1MigrationResponse parses an HTTP response from a GetApiV1MigrationWithResponse call
func ParseGetApiV1MigrationResponse(rsp *http.Response) (*GetApiV1MigrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiV1MigrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MigrationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostApiV1MigrationResponse parses an HTTP response from a PostApiV1MigrationWithResponse call
func ParsePostApiV1MigrationResponse(rsp *http.Response) (*PostApiV1MigrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiV1MigrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response The response message for the import.
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetApiV1PublicCollectionsLinksResponse parses an HTTP response from a GetApiV1PublicCollectionsLinksWithResponse call
func ParseGetApiV1PublicCollectionsLinksResponse(rsp *http.Response) (*GetApiV1PublicCollectionsLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiV1PublicCollectionsLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *[]struct {
				CollectionId  *int                                                 `json:"collectionId,omitempty"`
				Color         *string                                              `json:"color,omitempty"`
				CreatedAt     *time.Time                                           `json:"createdAt,omitempty"`
				CreatedById   *int                                                 `json:"createdById,omitempty"`
				Description   *string                                              `json:"description,omitempty"`
				Icon          *string                                              `json:"icon"`
				IconWeight    *GetApiV1PublicCollectionsLinks200ResponseIconWeight `json:"iconWeight"`
				Id            *int                                                 `json:"id,omitempty"`
				Image         *string                                              `json:"image"`
				ImportDate    *string                                              `json:"importDate"`
				LastPreserved *time.Time                                           `json:"lastPreserved"`
				Monolith      *string                                              `json:"monolith"`
				Name          *string                                              `json:"name,omitempty"`
				Pdf           *string                                              `json:"pdf"`
				Preview       *string                                              `json:"preview"`
				Readable      *string                                              `json:"readable"`
				Tags          *[]struct {
					CreatedAt *time.Time `json:"createdAt,omitempty"`
					Id        *int       `json:"id,omitempty"`
					Name      *string    `json:"name,omitempty"`
					OwnerId   *int       `json:"ownerId,omitempty"`
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"tags,omitempty"`
				TextContent *string    `json:"textContent"`
				Type        *string    `json:"type,omitempty"`
				UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
				Url         *string    `json:"url,omitempty"`
			} `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetApiV1PublicCollectionsTagsResponse parses an HTTP response from a GetApiV1PublicCollectionsTagsWithResponse call
func ParseGetApiV1PublicCollectionsTagsResponse(rsp *http.Response) (*GetApiV1PublicCollectionsTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiV1PublicCollectionsTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *[]struct {
				CreatedAt *time.Time `json:"createdAt,omitempty"`
				Id        *int       `json:"id,omitempty"`
				Name      *string    `json:"name,omitempty"`
				OwnerId   *int       `json:"ownerId,omitempty"`
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetApiV1PublicCollectionsIdResponse parses an HTTP response from a GetApiV1PublicCollectionsIdWithResponse call
func ParseGetApiV1PublicCollectionsIdResponse(rsp *http.Response) (*GetApiV1PublicCollectionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiV1PublicCollectionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetApiV1PublicLinksIdResponse parses an HTTP response from a GetApiV1PublicLinksIdWithResponse call
func ParseGetApiV1PublicLinksIdResponse(rsp *http.Response) (*GetApiV1PublicLinksIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiV1PublicLinksIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApiV1PublicUsersIdResponse parses an HTTP response from a GetApiV1PublicUsersIdWithResponse call
func ParseGetApiV1PublicUsersIdResponse(rsp *http.Response) (*GetApiV1PublicUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiV1PublicUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchLinksResponse parses an HTTP response from a SearchLinksWithResponse call
func ParseSearchLinksResponse(rsp *http.Response) (*SearchLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostApiV1SessionResponse parses an HTTP response from a PostApiV1SessionWithResponse call
func ParsePostApiV1SessionResponse(rsp *http.Response) (*PostApiV1SessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiV1SessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateTagResponse parses an HTTP response from a UpdateTagWithResponse call
func ParseUpdateTagResponse(rsp *http.Response) (*UpdateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTokensResponse parses an HTTP response from a GetTokensWithResponse call
func ParseGetTokensResponse(rsp *http.Response) (*GetTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokensResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateTokenData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRevokeTokenResponse parses an HTTP response from a RevokeTokenWithResponse call
func ParseRevokeTokenResponse(rsp *http.Response) (*RevokeTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *string `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Response *struct {
				ArchiveAsMonolith       *bool      `json:"archiveAsMonolith,omitempty"`
				ArchiveAsPDF            *bool      `json:"archiveAsPDF,omitempty"`
				ArchiveAsScreenshot     *bool      `json:"archiveAsScreenshot,omitempty"`
				ArchiveAsWaybackMachine *bool      `json:"archiveAsWaybackMachine,omitempty"`
				CollectionOrder         *[]int     `json:"collectionOrder,omitempty"`
				CreatedAt               *time.Time `json:"createdAt,omitempty"`
				Email                   *string    `json:"email"`
				EmailVerified           *string    `json:"emailVerified"`
				Id                      *int       `json:"id,omitempty"`
				Image                   *string    `json:"image,omitempty"`
				IsPrivate               *bool      `json:"isPrivate,omitempty"`
				LinksRouteTo            *string    `json:"linksRouteTo,omitempty"`
				Locale                  *string    `json:"locale,omitempty"`
				Name                    *string    `json:"name,omitempty"`
				ParentSubscription      *struct {
					User *map[string]interface{} `json:"user"`
				} `json:"parentSubscription"`
				PreventDuplicateLinks *bool                   `json:"preventDuplicateLinks,omitempty"`
				ReferredBy            *string                 `json:"referredBy"`
				Subscription          *map[string]interface{} `json:"subscription"`
				UpdatedAt             *time.Time              `json:"updatedAt,omitempty"`
				Username              *string                 `json:"username,omitempty"`
				WhitelistedUsers      *[]string               `json:"whitelistedUsers,omitempty"`
			} `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetDashboardV2Response parses an HTTP response from a GetDashboardV2WithResponse call
func ParseGetDashboardV2Response(rsp *http.Response) (*GetDashboardV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDashboardV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DashboardV2Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}
